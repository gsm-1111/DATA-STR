# 김성미
### 202330203

# 10-30 9주차 강의

# 스택이란?

## 스택(stack)
* 데이터를 일시적으로 저장하기 위해 사용하는 자료구조
* 데이터의 입력과 출력 순서는 후입선출(LIFO, Last In First Out)
* 즉, 가장 나중에 넣은 데이터를 가장 먼저 꺼냄
* 푸시(push): 스택에서 데이터를 넣는 작업
* 팝(pop): 스택에서 데이터를 꺼내는 작업
* 꼭대기(top): 푸시, 팝을 하는 위치
    * 테이블에 겹겹이 쌓은 접시처럼 데이터를 넣는 작업도 꺼내는 작업도 위쪽부터 수행
* 바닥(bottom): 스택의 가장 밑바닥 부분

## 스택의 구현 예
* 함수를 호출하고 실행할 때 프로그램 내부에서는 스택을 사용
* 가장 먼저 main 함수를 실행하며 main 함수는 z함수를 호출
* 호출된 함수 z는 x 함수와 y함수를 순서대로 호출
* 함수를 호출할 때는 푸시하고 함수가 실행을 종료하고 호출한 원래의 함수로 돌아갈 때는 함수를 팝함
* 예) main -> z -> x의 순서대로 함수를 호출
    * 이때 스택의 상태는 호출한 함수의 역순으로 겹겹이 쌓여 있어 함수 호출이 계층 구조로 이루어져 있음
    * 이 상태에서 x 함수의 실행이 종료되면 x함수만 팝함

## 스택 구조체(IntStack)
* 스택으로 사용할 배열을 가리키는 포인터 stk
    * 인덱스가 0인 요소를 스택의 바닥(bottom)이라 함
    * 배열의 메모리 공간 할당은 lnitialize 함수로 생성
* 스택의 최대 용량 max
    * 배열 stk의 요소 개수와 같음
* 스택 포인터 ptr
    * 스택에 쌓여있는 데이터의 개수를 나타냄
    * 스택이 비어 있으면 ptr의 값은 0이고 가득 차 있으면 max

## 





---



# 10-23 8주차 강의

# 검색 알고리즘
## 검색과 키 살펴보기
### 주소록 검색
* 이러한 검색의 공통점은 **특정 항목에 주목**한다는 점
* 그 **주목하는 항목은 키(key)**라고 함
* 예를 들어 국적을 검색하는 경우 국적이 키이고, 나이를 검색하는 경우 나이가 키
    1. 국적이 한국인 사람을 찾습니다.
    2. 나이가 21세 이상 27세 미만인 사람을 찾습니다.
    3. 어떤 낱말과 발음이 가장 비슷한 이름의 사람을 찾습니다.
* 데이터가 단순한 **정수 값**이면 데이터 값을 키 값이라고 생각해도 좋지만 대부분의 경우에는 **키는 데이터의 '일부'**
* 검색 과정을 살펴보면 **키 값을 아래처럼 지정**함
* 이런 조건은 **하나만 지정**하기도 하지만 **논리곱이나 논리합을 사용하여 복합해서 지정**하기도 함
    1. 키값과 일치하도록 지정합니다(한국).
    2. 키값의 구간을 지정합니다(21세 이상 27세 미만).
    3. 키값과 비슷하도록 지정합니다(발음이 가장 비슷한 이름).

## 배열에서 검색하기
### 배열 검색
* **선형 검색**: <u>무작위로 늘어놓은 데이터 모임</u>에서 검색을 수행
* **이진 검색**: <u>일정한 규칙으로 늘어놓은 데이터 모임</u>에서 아주 빠른 검색을 수행
* **해시법**: <u>추가, 삭제가 자주 일어나는 데이터 모임</u>에서 아주 빠른 검색을 수행
    * 체인법: 같은 해시값의 데이터를 선형 리스트로 연결하는 방법
    * 오픈 주소법: 데이터를 위한 해시값이 충돌할 때 재해시하는 방법

## 선형 검색
### 선형검색(linear search) 또는 순차 검색(sequential search)
* 요소가<u>직선 모양으로 늘어선 배열</u>에서의 검새은 원하는 키값을 갖는 요소를 만날 때까지 <u>맨 앞부터 순서대로 요소를 검색</u>
### 선형검색에서 배열 검색의 종료 조건
* ① 검색할 값을 <u>발견하지 못하고 배열의 끝을 지나간 경우 (검색 실패)</u>
* ② 검색할 값과 같은 요소를 <u>발견한 경우 (검색 성공)</u>
* 배열 요소의 개수가 n개일 때 ①,② 조건을 판단하는 횟수는 <u>**평균 n/2회**</u>
### 요소 개수가 n인 배열 a에서 값이 key인 요소를 검색하는 코드
* 배열을 검색할 때 배열 요소의 <u>인덱스를 가리키는 변수는 i</u>
* <u>i는 0으로 초기화</u>하고, 요소를 하나 검색할 때 마다 <u>while 문</u>이 제어하는 루프 본문의 <u>끝에서 증가</u>
* 배열 검색 종료 조건 중 <u>어느 하나라도 성립한 경우에는 while 문을 빠져나감</u>
```c
nt i = 0;
while (1) {
    if (i == n)
        return -1;
    if (a[i] == key)
          return i;
    i++;
}
```
### 보초법(sentinel method)
* 종료 조건을 검사하는 <u>비용을 반(50%)으로 줄이는 방법</u>
### 보초법을 이용한 선형 검색
* 배열의 요소 <u>a[0] ~ a[6]은 원래 데이터</u>
* 맨 끝 요소 <u>a[7]은 검색하기 전에 준비하는 보초</u>
* 원하는 값이 원래의 데이터에 존재하지 않아도 보초인 <u>a[7]까지 검색하면 **종료조건 ②가 성립(성공 조건)**</u>
* 이렇게 하면 원하는 키값을 찾지 못했을 때 <u>종료 조건 ①이 없어도 됨(실패 조건)</u>
* 보초는 반복문에서 <u>종료 판단 횟수를 2회에서 1회로 줄이는 역할</u>을 함
    
    선형 검색에서 배열 검색의 종료 조건<br>
    ① 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우(검색 실패)<br>
    ② 검색할 값과 같은 요소를 발견한 경우(검색 성공)

## 이진 검색
### 이진검색(binary search)
* 요소가 <u>오름차순 또는 내림차순으로 정렬된 배열에서 검색</u>하는 알고리즘
### 이진 검색에서 배열 검색의 종료 조건
1. <u>중앙 요소와 key가 일치하는 경우(검색 성공)</u>
2. <u>검색 범위가 더 이상 없는 경우(검색 실패)</u>
### 검색에 필요한 비교 횟수
* 이진 검색은 <u>검색을 반복할 때마다 검색 범위가 절반</u>이 되므로 검색에 필요한 <u>비교 횟수의 **평균값은 log n**</u>
* 검색에 <u>성공한 경우는 대략 log n -1 회</u>
* 검색에 <u>실패한 경우는  ⌈log(n + 1)⌉회</u>
    * ⌈ ⌉는 천장 함수(ceiling function)를 나타내는 기호로 올림 함수라고도 함
    * ⌈x⌉는 x의 천장 함수이며, x보다 크거나 같으면서 가장 작은 정수(예를 들어 ⌈3.5⌉는 4)
### 복잡도(complexity)
* <u>프로그램의 실행 속도</u>는 프로그램이 동작하는 하드웨어나 컴파일러 등의 조건에 따라 달라짐
* <u>**복잡도란 알고리즘의 성능을 객관적으로 평가하는 기준**</u>
### 복잡도의 두 가지 요소
1. 시간 복잡도(time complexity): 실행에 필요한 시간을 평가한 것
2. 공간 복잡도(space complexity): 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것
### bsearch
* C 언어의 표준 라이브러리는 다양한 요소의 자료형을 가진 배열에서도 검색 가능한 bsearch 함수를 제공
* bsearh라는 함수 이름은 이진 검색(binary search)에서 따왔지만, 내부적으로 항상 이진검색 알고리즘을 사용하지는 않음
* 함수의 특징
    * 특징 1: 검색 <u>대상의 배열은 항상 정렬</u>되어 있어야 함
    * 특징 2: <u>검색하는 값과 같은 요소가 여러 개 존재</u>하는 경우, 항상 <u>가장 앞쪽에 있는 요소</u>를 찾아내는 건 아님



---



# 10-02 7주차 강의

배열 요소를 역순으로 정렬

기수(진수) 변환

## 소수(prime number)
* 자신과 1 이외의 정수로 나누어 떨어지지 않는 정수
* 나누어 떨어지는 정수가 하나 이상 존재하면 그 수는 합성수(composite number)

## 다차원 배열
* 배열을 요소로 하는 배열
    * 배열을 자료형으로 하면 2차원 배열이고, 2차원 배열을 자료형으로 하면 3차원 배열
* 1차원 배열 : 지금까지 배운 '단일 자료형을 가지는 배열'
* 2차원 배열의 도출
    * [a] int형 ... int 자료형
    * [b] int[3]형 ... int를 자료형으로 하는 단일 요소가 3개인 배열
    * [c] int[4][3]형 ... int를 자료형을 하는 단일 요소가 3개인 배열을 자료형으로 하는 요소 개수가 4개인 배열

---
날짜를 계산하는 프로그램

# 구조체
* 구조체(structure) : 임의의 자료형의 요소를 조합하여 다시 만든 자료구조
* 구조체형과 멤버의 접근
    * [1] 구조체 선언
        * 구조체에 붙는 이름인 xyz를 구조체 태그(structure tag)라고 함
        * 구조체를 구성하는 요소를 구조체 멤버(structure member)라고 함
    * [2] 구조체형을 갖는 객체 a를 정의
        * struct xyz형을 갖는 객체 a를 정의
        * 구조체의 객체 안 멤버는 . 연산자를 사용하여 접근
    * [3] 포인터가 객체를 가리키도록 선언
        * p가 구조체형 객체에 대한 포인터일 때 p가 가리키는 객체의 멤버 x에 접근하는 형식은 -> 연산자를 사용 함

## 구조체 동의어 정의
* 구조체는 태그 이름 xyz만을 구조체 자료형의 이름으로 지정할 수 없음
* 구조체 자료형의 이름은 struct xyz처럼 두 단어로 구성해야 함
* typedef 선언을 사용해 짧은 이름으로 다시 만들어 사용할 수 있음
* 이제 하나의 단어 XYZ만으로 구조체 자료형의 이름을 나타낼 수 있음
* 이렇게 하면 변수 a와 포인터 p를 간단하게 선언하고 정의할 수 있음

### ![구조체 1](/img/구조체1.png "구조체1")



---



# 09-25 6주차 강의

# 배열

## 자료구조(data structure)의 정의
* 데이터 단위와 데이터 자체 사이의 물리적 또는 논리적인 관계

* 데이터 단위란?
    * 데이터를 구성하는 하나의 덩어리
    * 자료구조 : 자료를 효율적으로 사용할 수 있도록 컴퓨터에 저장하는 방법

## 배열(array)
* 배열은 **같은 자료형의 변수로 이루어진 요소(element)가 모여** 직선 모양으로 줄지어 있는 **자료구조**
* 네모 칸 안에 쓰인 숫자나 문자가 **요소 값**이고, 네모 칸의 왼쪽 또는 위쪽에 쓰인 작은 숫자가 **인덱스 값(index)**
###
### ![배열 1](/img/배열1.png "배열1")
* 그림 a처럼 요소를 **세로**로 정렬할 때는 인덱스가 작은 값을 **위쪽**에 오도록 함
* 그림 b처럼 요소를 **가로**로 정렬할 때는 인덱스가 작은 값을 **왼쪽**에 오도록 함
### ![배열 2](/img/배열2.png "배열2")

## 자료형 배열 이름[요소 개수]
* 배열의 선언
* 요소 개수는 **상수만 사용할 수 있음**
* 반드시 상수를 선언한 후에 사용하라는 의미X
* 일반적으로 배열을 선언할 때 대괄호 안에 숫자를 넣어 사용 → [5]

## 배열 이름[인덱스]
* 배열의 **개별 요소에 접근할 때 인덱스 식**(subscript expression)을 사용
* **첫 번째 배열 요소의 인덱스는 0**으로 정해져 있음
* 요소가 **n개인 배열**의 요소는 처음부터 순서대로 **a[0], a[1], ..., a[n - 1]로 접근**할 수 있음

## 변수 이름
* 임시로 사용할 변수는 메타변수를 사용(의미X)
* foo, bar, foobar, ...

## sizeof(배열명) / sizeof(자료형)
* 자료형에는 int, char, double 등을 사용.

## int[5]형 배열(자료형이 int형이고 요소가 3개)에 값을 입력해 출력
```c
#include <stdio.h>

int main()
{
    int foo[3];                     // 배열의 선언
    for (int i = 0; i < 3; i++) {   // 각 요소에 값을 입력
        printf("foo[%d] : ", i);
        scanf("&d", &foo[i]);
    }
    puts("각 요소의 값");
    for (int i =0; i < 3; i++) {    // 각 요소의 값을 출력
        printf("foo[%d] = %d\n", i, foo[i]);
    }

    return 0;
}
```
## int형 배열을 초기화하고 출력
```c
#include <stdio.h>

int main(void)
{
    int foo[5] = {1, 2, 3, 4, 5};
    int fooSize = sizeof(foo) / sizeof(foo[0]); // 요소의 개수
    printf("배열 a의 요소 개수는 %d입니다.\n", fooSize);

    for (int i = 0; i < fooSize; i++)
        printf("foo[%d] = %d\n", i, foo[i]);
        
        
    return 0;
}
```

## 메모리 할당과 동적 객체 생성하기
* 메모리 할당 : calloc, malloc 함수는 힙(heap)이라는 특별한 '빈 공간(free space)'에 기억 장소를 확보
    * calloc(clear and allocation) : 메모리를 할당하고 0으로 초기화.
    * malloc(memory allocation) : 메모리를 할당만 하고 초기화 하지 않음(가비지)
    * heap : 완전 이진 트리의 한 종류로 최대힙과 최소힙이 있음.

## 메모리 해제
* 확보한 **메모리가 불필요**하면 그 **공간을 해제**해야 하는데 이를 위해 제공되는 함수가 **free 함수**
* free 함수를 사용하면 프로그램을 실행하는 도중에도 원하는 시점에 **변수를 생성**하거나 제거할 수 있음
* free( ) 함수는 동적으로 할당된 메모리를 해제하는 역할을 함.
* calloc, malloc, free 함수를 사용하려면 stdlib.h를 include 해야 함.

## free 함수
* 헤더 : #include <stdlib.h>
* 형식 : void free(void *ptr);
* 반환값 : 없음

## int형 객체를 동적으로 생성하고 해제
```c
#include <stdio.h>
#include <stdlib.h>

int main(void){
int *x = calloc(1, sizeof(int));
    if (x == NULL)
        puts("메모리 할당에 실패했습니다.");
    else{
        *x =57;
        printf("*x= %d\n", *x);
        free(x);
    }

    return 0;
}
```

## 스택 메모리
* 스택(stack) 메모리는 자료구조의 스택(FIF0)과는 다름
    * 스택 메모리는 메모리 관리 방식이지 메모리 접근 방식이 아님.
    * 그렇기 때문에 FIF0를 따르는 것이 아닌, index를 통해 입출력 함.

## int형 배열을 동적으로 생성하고 해제
```c
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
    int el_num;
    printf("요소 개수 : ");
    scanf("%d", &el_num);
    int* foo = calloc(el_num, sizeof(int));

    if (foo == NULL)
        puts("메모리 확보에 실패했습니다.");
    else {
        printf("초기화 상태 확인.\n");
        for (int i = 0; i < el_num; i++) {
            printf("foo[%d] = %d\n", i, foo[i]);
        }
        printf("%d개의 정수를 입력하세요. \n", el_num);
        for (int i = 0; i < el_num; i++){
            printf("foo[%d] : ", i);
            scanf("%d", &foo[i]);
        }
        printf("각 요솟값은 아래와 같습니다.\n");
        for (int i = 0; i < el_num; i++)
            printf("foo[%d] = %d\n", i, foo[i]);
        free(foo);
    }

    return 0;
}
```

## 배열 요소의 최댓값 구하기
* 주사(traverse) : 배열의 요소를 하나씩 차레로 살펴보는 과정

```c
// 배열 요소의 최대 값을 구하고 출력(요소 값 입력)
#include <stdio.h>
#include <stdlib.h>

/*--- 요소 개수가 n 인 배열 a의 요소의 최댓값 ---*/
int maxof(const int foo[], int elem_cnt) {
    int max = foo[0];             // 최댓값
    for (int i = 1; i < elem_cnt; i++) {
        if (foo[i] > max) max = foo[i];
    }
    return max;
}

int main(void)
{
    int number;                 // 인원 = 배열 height의 요소 개수
    printf("사람 수: ");
    scanf("%d", &number);
    int *height = calloc(number, sizeof(int));  //요소 개수 number개인 배열을 생성
    printf("%d명의 키를 입력하세요.\n", number);
    for (int i = 0; i < number; i++) {
        printf("height[%d] : ", i);
        scanf("%d", &height[i]);
    }
    printf("최댓값은 %d입니다.\n", maxof(height, number));
    free(height);                               // 배열 height를 해제

    return 0;
}
```


---



# 09-18 5주차 강의

# 양수 음수 구분
```c
    // 입력받은 정숫값의 부호(양수/음수/0)를 판단
    #include<stdio.h>

    int main(void)
    {
        int n;

        printf("정수: ");
        scanf("%d", &n);

        if(n > 0)
            printf("양수입니다.\n");
        else if(n < 0)
            printf("음수입니다.\n");
        else
            printf("0입니다.\n");

        return 0;
    }
```
## 조건 연산자
* 3항 연산자 중에서 ?(물음표)를 **조건 연산자**라 함.
* 일반적으로 물음표의 앞 부분을 **조건절**이라 부름.
```c
    min = x < y ? x: y;
```
* 이 구문은 x가 y보다 작으면 x를, 그렇지 않으면 y를 min에 저장하라는 의미.

# 반복
* 반복 구조(repetition strucrure) 또는 루프(loop):
    * 어떤 조건이 성립하는 동안 처리(프로그램 명령문 또는 명령어의 집합)를 반복해 실행하는 것.
* While(제어식) 명령문
    : 반복의 대상이 되는 '명령문'을 문법적으로는 '루프 본문'이라 함
* 사전 판단 반복
    * 실행 전에 계속 반복할지를 판단.
    * 제어식의 평가 값이 0(false)이 아니면 프로그램 명령문을 반복.

## 1부터 n까지의 총합 구하기
```c
#include<stdio.h>

int main(void)
{
    int n;

    puts("1부터 n까지의 총합을 구합니다.");

    printf("n값: ");
    scanf("%d", &n);

    int sum = 0; // 총합
    int i = 1;
    int sum2 = 0;
    int sum3 = 0;

    while (i <= n)
    {               // i가 n 이하이면 반복
        sum += i;   // sum에 i를 추가
        i++;        // i값을 1증가
    }

    for (int j = 1; j <= n; j++)
    {
        sum2 += j;
    }

    // 가우스의 덧셈 알고리즘
    sum3 = n * (n + 1) / 2;
    printf("가우스의 덧셈 알고리즘으로 구한 1부터 %d까지의 총합은 %d입니다.\n", n, sum3);
    
    printf("while-1부터 %d까지의 총합은 %d입니다.\n", n, sum);
    printf("for-1부터 %d까지의 총합은 %d입니다.\n", n, sum2);

    return 0;
}
```
* while문은 언제 종료 될지 알 수 없는 반복문을 실행할 때 사용.
* for문은 종료 시점이 명확한 반복문을 실행할 때 사용.

## 다중 루프
* 반복 안에서 다시 반복할 수 있음
* 이런 반복을 루프가 중첩되는 수준에 따라 '이중 루프, 삼중 루프' 라고 함.

## 곱셈표
```c
#include <stdio.h>

int main(void)
{
    printf("----- 곱셈표 -----\n");

    for (int i =1; i <=9; i++)
    {
        for (int j = 1; j <= 9; j++)
            printf("%d X %d = %3d", i, j, i * j);
        putchar('\n');
    }

    return 0;
}
```
## 삼각형
```c
#include <stdio.h>

int main(void)
{
    int n;

    printf("몇 단 삼각형입니까?: ");
    scanf("%d", &n);

    //이등변 삼각형
    for (int i =1; i <= n; i++)
    {
        for (int j =1; j <= i; j++)
            putchar('*');
        putchar('\n');
    }

    // 삼각형
    for (int i = 0; i < n; i++)
    {
        for (int j = n-1; j > i; j--)
            putchar(' ');
        for (int j = 0; j < 2*i+1; j++)
            putchar('*');
        putchar('\n');
    }

    return 0;
}
```


---


# 09-11 4주차 강의

[chocolatey 설치 링크](https://chocolatey.org/install "chocolatey")

# 알고리즘
* 매개변수(Parameta) : 함수를 정의할 때 함수에 전달받은 값을 저장하는 변수.
* 인수(Argument) : 함수를 사용할 때 함수의 매개변수로 전달할 값.
* 함수를 호출하는 곳에서 argument를 함수에 전달하면, 함수는 전달받은 인수를 이용해서 함수를 실행한 후 return문으로 결과 값을 호출한 곳으로 보냄.
* return 값의 자료형이 void인 경우 값을 반환하지 않음.

## 알고리즘의 정의
어떤 문제를 해결하기 위한 절차로, 명확하게 정의되고 순서가 있는 유한 개의 규칙으로 이루어진 집합

- 올바른 알고리즘이란
    * '어떠한 경우에도 실행 결과가 똑같이 나오는 것'을 의미.
    * 만약 알고리즘의 실행 결과가 어떤 경우에는 맞고 어떤 경우에는 틀리면 올바른 알고리즘이라고 할 수 없음

# Hello World
* "hello world"를 출력하는 c프로그램.
    ```c
        #include <stdio.h>

        int main () {
            printf("hello world\n");
            return 0;
        }
    ```
* 터미널을 열고 명령 실행
    ```c
        $ gcc -o hello hello.c
    ```
* 명령 실행시 hello.exe 파일이 생성.
* 생성된 실행 파일을 다음과 같이 호출
    ```c
        $ ./hello
        PS> .hello
        >hello
    ```
* 오류가 나는 경우 VSCode 재실행

### 한글깨짐시
* VSCode 오른쪽 밑 UTF-8 클릭 후 인코딩하여 다시 열기 클릭. 본문이 깨졌을 땐 Ctrl + Z를 눌러주면 한글이 다시 돌아오고, 그 상태에서 저장 후 다시 컴파일 후 실행.

## 순서도(flowchart)
- 문제에 대한 정의, 분석, 해법을 그림으로 표현하는 방법.
- 프로그램 순서도(program flowchart)에서 사용되는 기호:
    * 실제로 수행하는 연산을 나타내는 기호
    * 제어의 흐름을 나타내는 기호
    * 프로그램 순서도를 이해하고 작성하는데 편의를 부여하는 특수 기호



---



# 09-04 3주차 강의

[문자 크기](#h1에-해당) / [리스트](#)

# # h1에 해당
## ## h2에 해당
### ### h3에 해당
#### #### h4에 해당
##### ##### h5에 해당
###### ###### h6에 해당

*\*이텔릭체**  
**\*\*볼드체\*\*** <br>
<u>\<u>밑줄\</u></u>

---

# 리스트
* \* 언오디드 리스트
- \- 언오디드 리스트
    * \* 탭
        * \*탭탭
            * \* 변화 없음


1. 오더드 리스트
2. 오더2

# 코드 블럭
```c
    #include <stdio.h>

    int main()
    {
        printf("Hello, world!\n");
        return 0;
    }
```

인라인 코드 블럭 예 : `<br>` 다른 예 : `ctrl`+`A`

# 외부링크
[구글로 가기](http://google.com "구글 링크")

![이미지](/img/images.png "이미지 삽입")