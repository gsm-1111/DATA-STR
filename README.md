# 김성미
### 202330203

---

# 11-13 12주차 강의

#

##





---

#  대림테크페어
![대림테크페어](img/소프트웨어학부.jpg "소프트웨어학부")
![대림테크페어](img/TTo.jpg "TTo")
![대림테크페어](img/우리의%20디스플레이.jpg "우리의 디스플레이")

---



# 11-06 11주차 강의

# 퀵 정렬

## qsort 함수
* qsort 함수는 bsearch 함수와 마찬가지로 int형이나 double형 등의 배열뿐만 아니라 구조체형 배열 등 모든 자료형의 배열에 적용할 수 있음
* qsort 함수에 전달하는 4개 인수는 앞에서부터 차례대로 배열의 첫 번째 요소에 대한 포인터, 요소의 개수, 요소의 크기, 비교 함수에 대한 포인터
* 비교 함수는 아래의 값을 반환하며 직접 작성해야 함
    * 첫 번째 인수가 가리키는 값이 더 작은 경우 음숫값(-1)을 반환
    * 첫 번째 인수가 가리키는 값과 두 번째 인수가 가리키는 값이 같은 경우 0을 반환
    * 첫 번째 인수가 가리키는 값이 더 큰 경우 양숫값(1)을 반환

## 시간 복잡도 참고
![시간 복잡도](img/시간%20복잡도.png "시간 복잡도 참고")


# 병합 정렬

## 병합(merge)
* <u>**# a,b모두 정렬이 끝난 배열이 조건!**</u>
* <u>'각 배열에서 선택한 요소의 값을 비교하여 작은 값의 요소를 꺼내 새로운 배열에 넣는 작업'을 반복</u>하여 정렬을 마치는 배열을 만듦
* merge 함수는 요소의 개수가 na개인 배열 a와 요소의 개수가 nb개인 배열 b를 병합하여 배열 c에 저장
* 이 함수에서는 세 개의 배열  a, b, c를 동시에 스캔
    * 이때 각 배열이 선택한 요소의 인덱스는 pa, pb, pc
    * 이 인덱스를 저장한 변수를 커서라고 함
* 처음에는 첫 요소를 선택하므로 커서를 모두 0으로 초기화

## 정렬을 마친 배열 병합하기
* ① 배열 a에서 선택한 요소(a[pa])와 배열 b에서 선택한 요소(b[pb])를 <u>**비교하여 작은 값을 c[pc]에 저장**</u>
    * 커서 pa, pb가 가리키는 값을 비교하여 작은 값을 c[pc]에 대입하고 커서 pa, pb, pc를 진행하는 <u>**작업을 반복**</u>
    * <u>**커서 pa가 배열 a의 끝에 다다르거나 커서 pb가 배열 b의 끝에 다다르면 이 작업을 종료**</u>
* ② 배열 <u>**a에는 아직 복사하지 못한 요소가 남아**</u> 있는 상태
    * 커서 pa를 한 칸씩 진행하면서 복사하지 않은 모든 배열 a의 요소를 배열 c에 복사
* ③ 배열 b에는 아직 복사하지 못한 요소가 남아 있는 상태
    * 커서 pb를 한 칸씩 진행하면서 복사하지 않은 모든 배열 b의 요소를 배열 c에 복사
```c
// 정렬을 마친 배열을 병합하는 프로그램
#include <stdio.h>
#include <stdlib.h>
/*--- 정렬을 마친 배열 a와 b를 병합하여 c에 저장 ---*/
void merge(const int a[], int na, const int b[], int nb, int c[])
{
    int pa = 0;
    int pb = 0;
    int pc = 0;
    while (pa < na && pb < nb)                          // ①
        c[pc++] = (a[pa] <= b[pb]) ? a[pa++] : b[pb++]; //
    while (pa < na)                                     // ②
        c[pc++] = a[pa++];                              //
    while (pb < nb)                                     // ③
        c[pc++] = b[pb++];                              //
}

int main(void)
{
    int na, nb;
    printf("a의 요소 개수: ");   scanf("%d", &na);
    printf("b의 요소 개수: ");   scanf("%d", &nb);
    int* a = calloc(na, sizeof(int));
    int* b = calloc(nb, sizeof(int));
    int* c = calloc(na + nb, sizeof(int));
    printf("a[0] : ");
    scanf("%d", &a[0]);
    for (int i = 1; i < na; i++) {
        do {
            printf("a[%d] : ", i);
            scanf("%d", &a[i]);
        } while (a[i] < a[i - 1]);
    }
    printf("b[0] : ");
    scanf("%d", &b[0]);
    for (int i = 1; i < nb; i++) {
        do {
            printf("b[%d] : ", i);
            scanf("%d", &b[i]);
        } while (b[i] < b[i - 1]);
    }

    // 배열 a와 b를 병합하여 c에 저장
    merge(a, na, b, nb, c);
    puts("배열 a와 b를 병합하여 배열 c에 저장했습니다.");
    for (int i = 0; i < na + nb; i++)
        printf("c[%2d] = %2d\n", i, c[i]);
    free(a);
    free(b);
    free(c);

    return 0;
}
```

## 병합 정렬(merge sort)
* <u>정렬을 마친 배열의 병합을 응용</u>하여 분할 정복법에 따라 정렬하는 알고리즘
* 먼저 배열을 <u>앞부분과 뒷부분으로 나눔</u>
* 나눈 <u>두 배열을 각각 정렬하고 병합</u>하면 배열 모두를 정렬할 수 있음

## 병합 정렬 알고리즘
* 배열의 요소가 2개 이상인 경우
    1. 배열의 앞부분을 병합 정렬로 정렬
    2. 배열의 뒷부분을 병합 정렬로 정렬
    3. 배열의 앞부분과 뒷부분을 병합

## 병합 정렬 참고
![병합 정렬](img/병합%20정렬.png "병합 정렬 참고")


# 힙 정렬

## 힙(heap)
* <u>**'부모의 값이 자식의 값보다 항상 크다'는 조건**</u>을 만족하는 완전 이진트리
* ⓐ는 <u>힙이 아닌 완전 이진트리</u>
* ⓐ를 힙으로 만들면 ⓑ와 같은 상태가 됨
* 부모와 자식 관게는 항상 '**부모의 값 ≧ 자식의 값**'
* 따라서 힙의 가장 위쪽에 있는 **루트가 가장 큰 값**이 됨
* **형제 사이의 대소 관계는 일정하지 않음**
![힙](img/힙.png "완전이진트리를 힙으로 전환하는 과정")

## 힙의 요소를 배열에 저장
* 가장 위쪽에 있는 **루트(10)를 a[0]에 넣음**
* 한 단계 아래 요소를 **왼쪽에서 오른쪽으로** 따라 감
* <u>인덱스의 값을 1씩 늘리면서</u> **배열의 각 요소에 힙의 요소를 대입**
* 이 과정을 거쳐 힙의 요소를 배열에 저장하면 부모와 자식의 인덱스 사이에 다음과 같은 관계가 성립
    1. 부모는 a[(i - 1) / 2]
    2. 왼쪽 자식은 a[i * 2 + 1]
    3. 오른쪽 자식은 a[i * 2 + 2]

## 힙 정렬
* <u>**'가장 큰 값이 루트에 위치'하는 특징을 이용**</u>하는 정렬 알고리즘
* 다음과 같은 작업을 반복해 그 과정에서 꺼낸 값을 늘어놓으면 정렬이 끝남
    * 힙에서 가장 큰 값인 루트를 꺼냄
    * 루트 이외의 부분을 힙으로 전환
* 힙 정렬은 선택 정렬을 응용한 알고리즘
* 힙에서 가장 큰 값인 루트를 꺼내고 **남은 요소에서 다시 가장 큰 값을 구해야 함**

## 루트를 없애고 힙 상태 유지하기
* 루트를 없앤 다음 다시 힙을 만들기 위해 요소를 알맞은 위치로 내려보내야 하는데 그 순서는 다음과 같음
    1. **루트를 꺼냄**
    2. **마지막 요소를 루트로 이동**
    3. **자기보다 큰 값을 가지는 자식 요소와 자리를 바꾸며 아래쪽으로 내려가는 작업을 반복**하는데 이때 **자식의 값이 작거나 잎에 다다르면 작업이 종료**됨

## 힙 이란?
* 우선순위 큐를 위해 고안된 완전이진트리 형태의 자료구조
* 여러 값 중, 최대값과 최소값을 빠르게 찾아내도록 만들어진 자료구조
* 반정렬 상태를 유지
* ex. 부모 노드의 키 값이 자식 노드의 키 값보다 항상 큼 / 작음
* 이진탐색트리(BST)와 달리 중복된 값이 허용된다.

## 트리의 종류와 힙
![이진 트리](img/이진%20트리.png "이진 트리")
---
![완전 이진 트리](img/완전%20이진%20트리.png "완전 이진 트리")
* 중간에 비어있는 노드가 없는 이진 트리
---
![최소/최대 힙](img/최소,최대%20힙.png "최소/최대 힙")
* 최대힙은 부모 노드가 자식 노드보다 큰 경우를 말한다. 최소힙은 반대.

# 도수 정렬

## 도수 정렬
* 지금까지의 정렬 알고리즘은 두 요소의 키값을 비교해야 했음
* 도수 정렬은 요소를 비교할 필요가 없다는 특징이 있음

## 도수 정렬 알고리즘
* 도수분포표 만들기
* 누적도수분포표 만들기
* 목적 배열 만들기
* 배열 복사하기

## 도수(개수) 정렬(counting sort)
* 데이터의 대소 관계를 직접 비교하지 않고 각 요소의 '도수(개수)'를 세어 정렬하는 알고리즘

# 정렬 방법의 시간 복잡도 비교
![시간 복잡도 비교](img/시간%20복잡도%20비교.png "정렬 방법의 시간 복잡도 비교")



---



# 10-31 10주차 강의

# 단순 선택 정렬

## 단순 선택 정렬(straight selection sort)
* 아직 정렬하지 않은 부분에서 값이 가장 작은 요소를 선택하고 아직 정렬하지 않은 부분의 첫 번째 요소와 교환

## 교환 과정
1. 아직 정렬하지 않은 부분에서 가장 작은 키의 값(a[min])을 선택
2. a[min]과 아직 정렬하지 않은 부분의 첫 번째 요소를 교환

## 실습
* 단순 선택 정렬을 수행하는 함수
* 단순 선택 정렬 알고리즘의 요솟값을 비교하는 횟수는 (n²-2)/2회
* 이 정렬 알고리즘은 서로 떨어져 있는 요소를 교환하는 것이기 때문에 안정적이지 않음
```c
/*--- 단순 선택 정렬 ---*/
// 단순 선택 정렬
#include <stdio.h>
#include <stdlib.h>
#define swap(type, x, y)  do { type t = x; x = y; y = t; } while (0)

/*--- 단순 선택 정렬 ---*/
void selection(int a[], int n)
{
    for (int i = 0; i < n - 1; i++) {
        int min = i;
        for (int j = i + 1; j < n; j++)
            if (a[j] < a[min])
                min = j;
        swap(int, a[i], a[min]);
    }
}

int main(void)
{
    int nx;

    puts("단순 선택 정렬");
    printf("요소 개수: ");
    scanf("%d", &nx);
    int* x = calloc(nx, sizeof(int));   // 요소 개수 nx의 int형 배열 x 생성

    for (int i = 0; i < nx; i++) {
        printf("x[%d] : ", i);
        scanf("%d", &x[i]);
    }

    selection(x, nx);                   // 배열 x를 단순 선택 정렬

    puts("오름차순으로 정렬했습니다.");
    for (int i = 0; i < nx; i++)
        printf("x[%d] = %d\n", i, x[i]);

    free(x);                            // 배열 해제

    return 0;
}
```


# 단순 삽입 정렬

## 단순 삽입 정렬(straight insertion sort)
* 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 '삽입하는' 작업을 반복하여 정렬하는 알고리즘
* 아직 정렬되지 않은 부분의 첫 번째 요소를 정렬된 부분의 알맞은 위치에 삽입
* 아래의 두 조건 중 하나를 만족할 때까지 j를 1씩 감소하면서 대입하는 작업을 반복
    1. 정렬된 열의 왼쪽 끝에 도달
    2. tmp보다 작거나 같은 key를 갖는 항목 a[j - 1]을 발견
* 드모르간 법칙 적용을 적용해 아래의 두 조건이 모두 성립할 때까지 반복
    1. j가 0보다 큼
    2. a[j - 1]값이 tmp보다 큼

## 단순 삽입 정렬의 특징
* 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라짐(장점)
* 삽입할 위치가 멀리 떨어져 있으면 이동(대입)해야 하는 횟수가 많아짐(단점)


# 셸 정렬

## 셸 정렬(shell sort)
* 단순 삽입 정렬의 장점은 살리고 단점은 보완한 정렬 알고리즘
* 정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행
* 그 그룹을 합치면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법

## 4-정렬
* 4칸만큼 떨어진 요소를 모아 그룹을 4개로 나누어 정렬하는 방법
* 아직 정렬을 마친 상태는 아니지만 정렬을 마친 상태에 가까워짐

## 2-정렬
* 2칸만큼 떨어진 요소를 모아 두 그룹({7, 3, 8, 4}, {1, 2, 6, 5})으로 나누어 '2-정렬'을 함
* 정렬을 마치고 나면 각각의 그룹은 {3, 4, 7, 8}, {1, 2, 5, 6}으로 정렬됨

## h-정렬
* 셸 정렬 과정에서 수행하는 각각의 정렬
    1. 2개 요소에 대해 '4-정렬'(4개의 그룹)
    2. 4개 요소에 대해 '2-정렬'(2개의 그룹)
    3. 8개 요소에 대해 '1-정렬'(1개의 그룹)

## 증분값(h값)의 선택
* h값은 n부터 감소하여 마지막에 1이 되면 돈
* 그림의 서로 다른 색으로 표현한 이들 두 그룹은 서로 섞이지 않음
* 이렇게 그룹이 섞이지 않으면 c 를 합쳤을 때 다시 처음 단계인 a 와 동일한 상태가 됨
* 그러면 다시 a 의 학생을 정렬하는 것과 같아서 기껏 그룹을 나누었음에도 정렬 알고리즘이 충분히 작동하지 않음
* h값이 서로 배수가 되지 않도록 해야 요소가 충분히 섞여 효율적인 정렬을 기대할 수 있음
* 아래 수열을 거꾸로 살펴보면 1부터 시작하여 3배한 값에 1을 더하는 수열
    * h = ..., → 121 → 40 → 13 → 4 → 1
![증분값의 선택](img/증분값.png "셀 정렬의 그룹 분할 과정(h = 4, 2, 1)")


# 퀵 정렬

## 퀵 정렬(quick sort)
* 일반적으로 사용되고 있는 아주 빠른 정렬 알고리즘
* 그림은 이 알고리즘으로 학생 수가 8명인 그룹을 키 순서대로 정렬한 모습을 나타낸 것
* 먼저 어느 한 사람의 키를 선택
* 키가 168cm인 학생 A를 선택할 경우 그 학생을 기준으로 학생 A의 키보다 작은 사람의 그룹과 큰 사람의 그룹으로 나눔
* 이때 학생 A의 키를(그룹을 나누는 기준) 피벗(pivot)이라고 함
* 퀵 정렬은 각 그룹에 대해 피벗 설정과 그룹 나눔을 반복하며 모든 그룹이 1명이 되면 정렬을 마침
![퀵 정렬](img/퀵%20정렬.png "퀵 정렬 과정")

## 배열을 두 그룹으로 나누기
* 그룹을 나누려면 피벗 이하의 요소를 배열 왼쪽으로, 이상의 요소를 배열 오른쪽으로 옮겨야 함
    1. a[pl] >= x가 성립하는 요소를 찾을 떄까지 pl을 오른쪽으로 옮김
    2. a[pr] <= x가 성립하는 요소를 찾을 떄까지 pr을 왼쪽으로 옮김
* pl이 위치한 지점은 피벗값 이상의 요소가 있는 지점이고 pr이 위치한 지점은 피벗 값 이하의 요소가 있는 지점
* pl과 pr이 교차하면 그룹을 나누는 과정이 끝나고 배열은 아래처럼 두 그룹으로 나누어짐
    * 피벗 이하의 그룹: a[0], ..., a[pl - 1]
    * 피벗 이상의 그룹: a[pr + 1], ..., a[n - 1]

## 피벗과 같은 값을 가지는 그룹
* 그룹을 나누는 작업이 끝난 다음 pl > pr + 1인 경우에는 다음과 같은 그룹이 생길 수 있음
    * 피벗과 일치하는 값을 가지는 그룹: a[pr + 1], ..., a[pl - 1]
* ⓐ ⓑ ⓒ 왼쪽 커서, 오른쪽 커서가 피벗 이상, 피벗 이하의 요소를 찾아 멈춘 단계
* ⓓ pl, pr이 동일한 요소 a[4] 위에 있음
* 이때 동일한 요소인 a[4]와 a[4]를 교환
* 동일한 요소를 교환하는 시도가 의미 없어 보이지만 이 시도는 아무리 많아야 1회이므로 해도 괜찮음
* ⓔ 계속 스캔하면 pl, pr이 교차하면서 그룹을 나누는 과정을 마침
![피벗](img/피벗.png "피벗과 같은 값을 가지는 그룹이 생긴 경우")

```c
// 배열을 나누는 프로그램
#include <stdio.h>
#include <stdlib.h>

#define swap(type, x, y)  do { type t = x; x = y; y = t; } while (0)

/*--- 배열을 나누는 함수 ---*/
void partition(int a[], int n)
{
    int pl = 0;         // 왼쪽 커서
    int pr = n - 1;     // 오른쪽 커서
    int x = a[n / 2];   // 피벗은 가운데 요소를 선택
    do {
        while (a[pl] < x) pl++;
        while (a[pr] > x) pr--;
        if (pl <= pr) {
            swap(int, a[pl], a[pr]);
            pl++;
            pr--;
        }
    } while (pl <= pr);
    printf("피벗의 값은 %d입니다.\n", x);
    printf("피벗 이하의 그룹\n");              // 피벗 이하의 그룹
    for (int i = 0; i <= pl - 1; i++)     // a[0] ~ a[pl – 1]
        printf("%d ", a[i]);
    putchar('\n');
    if (pl > pr + 1) {
        printf("피벗과 일치하는 그룹\n");            // 피벗과 같은 그룹
        for (int i = pr + 1; i <= pl - 1; i++) // [pr + 1] ~ a[pl – 1]
            printf("%d ", a[i]);
        putchar('\n');
    }
    printf("피벗 이상의 그룹\n");              // 피벗 이상의 그룹
    for (int i = pr + 1; i < n; i++)      // a[pr + 1] ~ a[n – 1]
        printf("%d ", a[i]);
    putchar('\n');
}

int main(void)
{
    int nx;
    puts("배열을 나눕니다.");
    printf("요소 개수: ");
    scanf("%d", &nx);
    int *x = calloc(nx, sizeof(int));   // 요소의 개수가 nx인 int형 배열 x를 생성
    for (int i = 0; i < nx; i++) {
        printf("x[%d] : ", i);
        scanf("%d", &x[i]);
    }
    partition(x, nx);                   // 배열 x를 분할
    free(x);                            // 배열 x를 해제

    return 0;
}
```



---



# 10-30 9주차 강의

# 스택

## 스택(stack)
* 데이터를 일시적으로 저장하기 위해 사용하는 자료구조
* 데이터의 입력과 출력 순서는 후입선출(LIFO, Last In First Out)
* 즉, 가장 나중에 넣은 데이터를 가장 먼저 꺼냄
* 푸시(push): 스택에서 데이터를 넣는 작업
* 팝(pop): 스택에서 데이터를 꺼내는 작업
* 꼭대기(top): 푸시, 팝을 하는 위치
    * 테이블에 겹겹이 쌓은 접시처럼 데이터를 넣는 작업도 꺼내는 작업도 위쪽부터 수행
* 바닥(bottom): 스택의 가장 밑바닥 부분

## 스택의 구현 예
* 함수를 호출하고 실행할 때 프로그램 내부에서는 스택을 사용
* 가장 먼저 main 함수를 실행하며 main 함수는 z함수를 호출
* 호출된 함수 z는 x 함수와 y함수를 순서대로 호출
* 함수를 호출할 때는 푸시하고 함수가 실행을 종료하고 호출한 원래의 함수로 돌아갈 때는 함수를 팝함
* 예) main -> z -> x의 순서대로 함수를 호출
    * 이때 스택의 상태는 호출한 함수의 역순으로 겹겹이 쌓여 있어 함수 호출이 계층 구조로 이루어져 있음
    * 이 상태에서 x 함수의 실행이 종료되면 x함수만 팝함

## 스택 구조체(IntStack)
* 스택으로 사용할 배열을 가리키는 포인터 stk
    * 인덱스가 0인 요소를 스택의 바닥(bottom)이라 함
    * 배열의 메모리 공간 할당은 lnitialize 함수로 생성
* 스택의 최대 용량 max
    * 배열 stk의 요소 개수와 같음
* 스택 포인터 ptr
    * 스택에 쌓여있는 데이터의 개수를 나타냄
    * 스택이 비어 있으면 ptr의 값은 0이고 가득 차 있으면 max

## 초기화 함수(lnitialize)
* 스택의 메모리 공간(배열)을 확보하는 등의 준비 작업을 수행하는 함수
* 배열을 위한 메모리 공간을 만들 때 스택은 비어있어야(하나도 쌓여있지 않은 상태여야)하므로 스택 포인터 ptr 값을 0으로 함
* 요소의 개수가 max인 배열 stk를 생성함 이때, 스택의 개별 요소에 접근하는 인덱스 식은 바닥(bottom)부터 stk[0], stk[1], ..., stk[max-1]이 됨
* 매개변수 max로 받은 값을 스택 최대 용량을 나타내는 구조체의 멤버 max에 저장

```c
// int형 스택 IntStack(소스)
#include <stdio.h>
#include <stdlib.h>
#include "IntStack.h"

/*--- 스택 초기화 ---*/
int lnitialize(IntStack *s, int max)
{
    s->ptr = 0;
    if((s->stk = calloc(max, sizeof(int))) == NULL) {
        s->max = 0; //배열의 생성에 실패
        return -1;
    }
    s->max = max;
    return 0;
}
```


# 큐

## 큐(queue)
* 데이터를 일시적으로 쌓아두기 위한 자료구조
* 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출 구조를 이룸
* 은행 창구에서 차례를 기다리는 대기열이나 마트에서 계산을 기다리는 대기열과 같은
* 인큐(en-queue): 큐에 데이터를 넣는 작업
* 디큐(de-queue): 데이터를 꺼내는 작업
* 프런트(front): 데이터를 꺼내는 쪽
* 리어(rear): 데이터를 넣는 쪽

## 배열로 큐 만들기
### 큐의 구현 예
* 배열의 프런트(front)부터 4개(19, 22, 37, 53)의 데이터가 들어가 있는 모습
* 24 인큐
    * 리어(rear)의 데이터가 저장된 que[3]의 다음요소 que[4]에 24를 저장
    * 이 처리의 복잡도는 O(1) 이고 적은 비용으로 구현할 수 있음
* 19 디큐
    * QUE[0]에 저장되 19를 꺼낸 다음 두 번째 이후의 요소를 모두 맨 앞으로 옮김
    * 이 처리의 복잡도는 O(n) 이며 데이터를 꺼낼 때마다 이런 처리를 하게 되면 효율이 떨어짐
![큐의 구현 예](img/큐의%20구현%20예.png "배열에 의한 큐의 구현 예")

## 링 버퍼(ring buffer)
* 배열의 처음이 끝과 연결되었다고 보는 자료구조
* 프런트(front): 논리적인 맨 처음 요소의 인덱스
* 리어(rear): 논리적인 맨 끝 요소의 하나 뒤의 인덱스(다음 요소를 인큐할 위치를 미리 지정)
* 변수 프런트와 리어의 값은 인큐와 디큐를 수행함에 따라 변화하는데 이 때문에 배열 요소를 앞쪽으로 옮기지 않는 큐를 구현할 수 있음
* 처리의 복잡도는 O(1)
![링 버퍼](img/링%20버퍼.png "링 버퍼를 사용하는 큐의 구현")

## 링 버퍼에 대한 인큐와 디큐
* 7개의 데이터(35,56,24,68,95,73,19)가 차례대로 que[7], que[8], ..., que[11], que[0], que[1]에 저장
    * 프러트값은 7이고 리어값은 2
* 82를 인큐한 다음의 상태
    * que[2](리어가 가리키고 있는 위치)에 82를 저장한 다음 리어값을 1만큼 증가
* 35를 디큐한 다음의 상태
    * 프런트 요소(que[front], 즉 que[7]의 값 35를 빼고 프런트 값을 1만큼 증가)
![링 버퍼2](img/링%20버퍼2.png "링 버퍼에 대한 인큐와 디큐")

### 모든 데이터를 출력하는 함수 Print
* 큐의 모든 데이터를 처음부터 끝까지 순서대로 출력하는 함수

### 종료함수 Terminate
* 메모리 공간에 할당한 배열(큐)을 해제하는 함수


# 요약
### 1. Stack 후입 선출 LIFO
### 2. Queue 선입 선출 FIFO(rew, front 변수를 수정)
### 3. 원형 큐(링 버퍼 큐)


# 정렬(sorting)
* 이름, 학번, 키 등 핵심항목(key)의 대소관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업
* 키값이 작은 데이터를 앞쪽에 놓으면 오름차순(ascending order) 정렬, 그 반대로 놓으면 내림차순(descending order) 정렬이라고 부름

## 정렬 알고리즘의 안정성
* 안정된 정렬이란 같은 값의 키를 가진 요소의 순서가 정렬 전후에도 유지되는 것

## 정렬 알고리즘의 핵심 요소
* 교환, 선택, 삽입


# 버블 정렬

## 패스(pass)

* 이웃한 요소를 비교하고 교환하는 작업을 첫 번째 요소까지 계속하면 아래 그림과 같은 상태가 됨
* 요소의 개수가 n개인 배열에서 n - 1회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동함
* 이런 일련의 과정(비교, 교환 작업)을 패스(pass)라고 함
![버블 정렬](img/버블%20정렬.png "버블 정렬의 첫 번째 패스")

## 패스 수행 횟수
* 두 번째 패스의 비교 횟수는 첫 번째 패스보다 1회 적은 n - 2회
* 왜냐하면 패스를 1회 수행할 때마다 정렬할 요소가 하나씩 줄어들기 때문
* 패스를 k회 수행하면 앞쪽의 요소 k개가 정렬
* 모든 정렬이 끝나려면 n - 1회의 패스가 수행되어야 함

## 버블 정렬 알고리즘
* 비교하는 두 요소의 인덱스를 j - 1과 j라 함
* 배열의 끝(오른쪽)부터 스캔하기 때문에 j의 시작값은 n - 1
* 한 번의 패스에서는 j값이 i + 1이 될 때까지 비교, 교환을 수행하면 됨
* 비교 횟수는 첫 번째 패스는 n - 1회, 두 번째 패스는 n - 2회, ... 이므로 n(n - 1)/2회
* 실제 요소를 교환하는 횟수는 배열의 요솟값에 더 많이 영향을 받기 때문에 교환 횟수의 평균값은 비교 횟수의 절반인 n(n - 1)/4회
* 또한 swap 함수 안에서 값의 이동이 3회 발생하므로 이동 횟수의 평균은 3n(n - 1)/4회

## 알고리즘 개선
* 이미 배열이 정렬을 마친 상태라면 그 이후의 패스는 요소 교환을 하지 않음
* 즉, 어떤 패스에서 요소의 교환 횟수가 0이면 더 이상 정렬할 요소가 없다는 뜻이기 때문에 정렬 작업을 멈추면 됨
* 어떤 시점 이후에 교환이 수행되지 않는다면 그보다 앞쪽의 요소는 이미 정렬을 마친 상태라고 생각해도 좋음



---



# 10-23 8주차 강의

# 검색 알고리즘

## 검색과 키 살펴보기
### 주소록 검색
* 이러한 검색의 공통점은 **특정 항목에 주목**한다는 점
* 그 **주목하는 항목은 키(key)**라고 함
* 예를 들어 국적을 검색하는 경우 국적이 키이고, 나이를 검색하는 경우 나이가 키
    1. 국적이 한국인 사람을 찾습니다.
    2. 나이가 21세 이상 27세 미만인 사람을 찾습니다.
    3. 어떤 낱말과 발음이 가장 비슷한 이름의 사람을 찾습니다.
* 데이터가 단순한 **정수 값**이면 데이터 값을 키 값이라고 생각해도 좋지만 대부분의 경우에는 **키는 데이터의 '일부'**
* 검색 과정을 살펴보면 **키 값을 아래처럼 지정**함
* 이런 조건은 **하나만 지정**하기도 하지만 **논리곱이나 논리합을 사용하여 복합해서 지정**하기도 함
    1. 키값과 일치하도록 지정합니다(한국).
    2. 키값의 구간을 지정합니다(21세 이상 27세 미만).
    3. 키값과 비슷하도록 지정합니다(발음이 가장 비슷한 이름).

## 배열에서 검색하기
### 배열 검색
* **선형 검색**: <u>무작위로 늘어놓은 데이터 모임</u>에서 검색을 수행
* **이진 검색**: <u>일정한 규칙으로 늘어놓은 데이터 모임</u>에서 아주 빠른 검색을 수행
* **해시법**: <u>추가, 삭제가 자주 일어나는 데이터 모임</u>에서 아주 빠른 검색을 수행
    * 체인법: 같은 해시값의 데이터를 선형 리스트로 연결하는 방법
    * 오픈 주소법: 데이터를 위한 해시값이 충돌할 때 재해시하는 방법

## 선형 검색
### 선형검색(linear search) 또는 순차 검색(sequential search)
* 요소가<u>직선 모양으로 늘어선 배열</u>에서의 검새은 원하는 키값을 갖는 요소를 만날 때까지 <u>맨 앞부터 순서대로 요소를 검색</u>
### 선형검색에서 배열 검색의 종료 조건
* ① 검색할 값을 <u>발견하지 못하고 배열의 끝을 지나간 경우 (검색 실패)</u>
* ② 검색할 값과 같은 요소를 <u>발견한 경우 (검색 성공)</u>
* 배열 요소의 개수가 n개일 때 ①,② 조건을 판단하는 횟수는 <u>**평균 n/2회**</u>
### 요소 개수가 n인 배열 a에서 값이 key인 요소를 검색하는 코드
* 배열을 검색할 때 배열 요소의 <u>인덱스를 가리키는 변수는 i</u>
* <u>i는 0으로 초기화</u>하고, 요소를 하나 검색할 때 마다 <u>while 문</u>이 제어하는 루프 본문의 <u>끝에서 증가</u>
* 배열 검색 종료 조건 중 <u>어느 하나라도 성립한 경우에는 while 문을 빠져나감</u>
```c
nt i = 0;
while (1) {
    if (i == n)
        return -1;
    if (a[i] == key)
          return i;
    i++;
}
```
### 보초법(sentinel method)
* 종료 조건을 검사하는 <u>비용을 반(50%)으로 줄이는 방법</u>
### 보초법을 이용한 선형 검색
* 배열의 요소 <u>a[0] ~ a[6]은 원래 데이터</u>
* 맨 끝 요소 <u>a[7]은 검색하기 전에 준비하는 보초</u>
* 원하는 값이 원래의 데이터에 존재하지 않아도 보초인 <u>a[7]까지 검색하면 **종료조건 ②가 성립(성공 조건)**</u>
* 이렇게 하면 원하는 키값을 찾지 못했을 때 <u>종료 조건 ①이 없어도 됨(실패 조건)</u>
* 보초는 반복문에서 <u>종료 판단 횟수를 2회에서 1회로 줄이는 역할</u>을 함
    
    선형 검색에서 배열 검색의 종료 조건<br>
    ① 검색할 값을 발견하지 못하고 배열의 끝을 지나간 경우(검색 실패)<br>
    ② 검색할 값과 같은 요소를 발견한 경우(검색 성공)

## 이진 검색
### 이진검색(binary search)
* 요소가 <u>오름차순 또는 내림차순으로 정렬된 배열에서 검색</u>하는 알고리즘
### 이진 검색에서 배열 검색의 종료 조건
1. <u>중앙 요소와 key가 일치하는 경우(검색 성공)</u>
2. <u>검색 범위가 더 이상 없는 경우(검색 실패)</u>
### 검색에 필요한 비교 횟수
* 이진 검색은 <u>검색을 반복할 때마다 검색 범위가 절반</u>이 되므로 검색에 필요한 <u>비교 횟수의 **평균값은 log n**</u>
* 검색에 <u>성공한 경우는 대략 log n -1 회</u>
* 검색에 <u>실패한 경우는  ⌈log(n + 1)⌉회</u>
    * ⌈ ⌉는 천장 함수(ceiling function)를 나타내는 기호로 올림 함수라고도 함
    * ⌈x⌉는 x의 천장 함수이며, x보다 크거나 같으면서 가장 작은 정수(예를 들어 ⌈3.5⌉는 4)
### 복잡도(complexity)
* <u>프로그램의 실행 속도</u>는 프로그램이 동작하는 하드웨어나 컴파일러 등의 조건에 따라 달라짐
* <u>**복잡도란 알고리즘의 성능을 객관적으로 평가하는 기준**</u>
### 복잡도의 두 가지 요소
1. 시간 복잡도(time complexity): 실행에 필요한 시간을 평가한 것
2. 공간 복잡도(space complexity): 기억 영역과 파일 공간이 얼마나 필요한가를 평가한 것
### bsearch
* C 언어의 표준 라이브러리는 다양한 요소의 자료형을 가진 배열에서도 검색 가능한 bsearch 함수를 제공
* bsearh라는 함수 이름은 이진 검색(binary search)에서 따왔지만, 내부적으로 항상 이진검색 알고리즘을 사용하지는 않음
* 함수의 특징
    * 특징 1: 검색 <u>대상의 배열은 항상 정렬</u>되어 있어야 함
    * 특징 2: <u>검색하는 값과 같은 요소가 여러 개 존재</u>하는 경우, 항상 <u>가장 앞쪽에 있는 요소</u>를 찾아내는 건 아님



---



# 10-02 7주차 강의

배열 요소를 역순으로 정렬

기수(진수) 변환

## 소수(prime number)
* 자신과 1 이외의 정수로 나누어 떨어지지 않는 정수
* 나누어 떨어지는 정수가 하나 이상 존재하면 그 수는 합성수(composite number)

## 다차원 배열
* 배열을 요소로 하는 배열
    * 배열을 자료형으로 하면 2차원 배열이고, 2차원 배열을 자료형으로 하면 3차원 배열
* 1차원 배열 : 지금까지 배운 '단일 자료형을 가지는 배열'
* 2차원 배열의 도출
    * [a] int형 ... int 자료형
    * [b] int[3]형 ... int를 자료형으로 하는 단일 요소가 3개인 배열
    * [c] int[4][3]형 ... int를 자료형을 하는 단일 요소가 3개인 배열을 자료형으로 하는 요소 개수가 4개인 배열

---
날짜를 계산하는 프로그램

# 구조체
* 구조체(structure) : 임의의 자료형의 요소를 조합하여 다시 만든 자료구조
* 구조체형과 멤버의 접근
    * [1] 구조체 선언
        * 구조체에 붙는 이름인 xyz를 구조체 태그(structure tag)라고 함
        * 구조체를 구성하는 요소를 구조체 멤버(structure member)라고 함
    * [2] 구조체형을 갖는 객체 a를 정의
        * struct xyz형을 갖는 객체 a를 정의
        * 구조체의 객체 안 멤버는 . 연산자를 사용하여 접근
    * [3] 포인터가 객체를 가리키도록 선언
        * p가 구조체형 객체에 대한 포인터일 때 p가 가리키는 객체의 멤버 x에 접근하는 형식은 -> 연산자를 사용 함

## 구조체 동의어 정의
* 구조체는 태그 이름 xyz만을 구조체 자료형의 이름으로 지정할 수 없음
* 구조체 자료형의 이름은 struct xyz처럼 두 단어로 구성해야 함
* typedef 선언을 사용해 짧은 이름으로 다시 만들어 사용할 수 있음
* 이제 하나의 단어 XYZ만으로 구조체 자료형의 이름을 나타낼 수 있음
* 이렇게 하면 변수 a와 포인터 p를 간단하게 선언하고 정의할 수 있음

### ![구조체 1](/img/구조체1.png "구조체1")



---



# 09-25 6주차 강의

# 배열

## 자료구조(data structure)의 정의
* 데이터 단위와 데이터 자체 사이의 물리적 또는 논리적인 관계

* 데이터 단위란?
    * 데이터를 구성하는 하나의 덩어리
    * 자료구조 : 자료를 효율적으로 사용할 수 있도록 컴퓨터에 저장하는 방법

## 배열(array)
* 배열은 **같은 자료형의 변수로 이루어진 요소(element)가 모여** 직선 모양으로 줄지어 있는 **자료구조**
* 네모 칸 안에 쓰인 숫자나 문자가 **요소 값**이고, 네모 칸의 왼쪽 또는 위쪽에 쓰인 작은 숫자가 **인덱스 값(index)**
###
### ![배열 1](/img/배열1.png "배열1")
* 그림 a처럼 요소를 **세로**로 정렬할 때는 인덱스가 작은 값을 **위쪽**에 오도록 함
* 그림 b처럼 요소를 **가로**로 정렬할 때는 인덱스가 작은 값을 **왼쪽**에 오도록 함
### ![배열 2](/img/배열2.png "배열2")

## 자료형 배열 이름[요소 개수]
* 배열의 선언
* 요소 개수는 **상수만 사용할 수 있음**
* 반드시 상수를 선언한 후에 사용하라는 의미X
* 일반적으로 배열을 선언할 때 대괄호 안에 숫자를 넣어 사용 → [5]

## 배열 이름[인덱스]
* 배열의 **개별 요소에 접근할 때 인덱스 식**(subscript expression)을 사용
* **첫 번째 배열 요소의 인덱스는 0**으로 정해져 있음
* 요소가 **n개인 배열**의 요소는 처음부터 순서대로 **a[0], a[1], ..., a[n - 1]로 접근**할 수 있음

## 변수 이름
* 임시로 사용할 변수는 메타변수를 사용(의미X)
* foo, bar, foobar, ...

## sizeof(배열명) / sizeof(자료형)
* 자료형에는 int, char, double 등을 사용.

## int[5]형 배열(자료형이 int형이고 요소가 3개)에 값을 입력해 출력
```c
#include <stdio.h>

int main()
{
    int foo[3];                     // 배열의 선언
    for (int i = 0; i < 3; i++) {   // 각 요소에 값을 입력
        printf("foo[%d] : ", i);
        scanf("&d", &foo[i]);
    }
    puts("각 요소의 값");
    for (int i =0; i < 3; i++) {    // 각 요소의 값을 출력
        printf("foo[%d] = %d\n", i, foo[i]);
    }

    return 0;
}
```
## int형 배열을 초기화하고 출력
```c
#include <stdio.h>

int main(void)
{
    int foo[5] = {1, 2, 3, 4, 5};
    int fooSize = sizeof(foo) / sizeof(foo[0]); // 요소의 개수
    printf("배열 a의 요소 개수는 %d입니다.\n", fooSize);

    for (int i = 0; i < fooSize; i++)
        printf("foo[%d] = %d\n", i, foo[i]);
        
        
    return 0;
}
```

## 메모리 할당과 동적 객체 생성하기
* 메모리 할당 : calloc, malloc 함수는 힙(heap)이라는 특별한 '빈 공간(free space)'에 기억 장소를 확보
    * calloc(clear and allocation) : 메모리를 할당하고 0으로 초기화.
    * malloc(memory allocation) : 메모리를 할당만 하고 초기화 하지 않음(가비지)
    * heap : 완전 이진 트리의 한 종류로 최대힙과 최소힙이 있음.

## 메모리 해제
* 확보한 **메모리가 불필요**하면 그 **공간을 해제**해야 하는데 이를 위해 제공되는 함수가 **free 함수**
* free 함수를 사용하면 프로그램을 실행하는 도중에도 원하는 시점에 **변수를 생성**하거나 제거할 수 있음
* free( ) 함수는 동적으로 할당된 메모리를 해제하는 역할을 함.
* calloc, malloc, free 함수를 사용하려면 stdlib.h를 include 해야 함.

## free 함수
* 헤더 : #include <stdlib.h>
* 형식 : void free(void *ptr);
* 반환값 : 없음

## int형 객체를 동적으로 생성하고 해제
```c
#include <stdio.h>
#include <stdlib.h>

int main(void){
int *x = calloc(1, sizeof(int));
    if (x == NULL)
        puts("메모리 할당에 실패했습니다.");
    else{
        *x =57;
        printf("*x= %d\n", *x);
        free(x);
    }

    return 0;
}
```

## 스택 메모리
* 스택(stack) 메모리는 자료구조의 스택(FIF0)과는 다름
    * 스택 메모리는 메모리 관리 방식이지 메모리 접근 방식이 아님.
    * 그렇기 때문에 FIF0를 따르는 것이 아닌, index를 통해 입출력 함.

## int형 배열을 동적으로 생성하고 해제
```c
#include <stdio.h>
#include <stdlib.h>
int main(void)
{
    int el_num;
    printf("요소 개수 : ");
    scanf("%d", &el_num);
    int* foo = calloc(el_num, sizeof(int));

    if (foo == NULL)
        puts("메모리 확보에 실패했습니다.");
    else {
        printf("초기화 상태 확인.\n");
        for (int i = 0; i < el_num; i++) {
            printf("foo[%d] = %d\n", i, foo[i]);
        }
        printf("%d개의 정수를 입력하세요. \n", el_num);
        for (int i = 0; i < el_num; i++){
            printf("foo[%d] : ", i);
            scanf("%d", &foo[i]);
        }
        printf("각 요솟값은 아래와 같습니다.\n");
        for (int i = 0; i < el_num; i++)
            printf("foo[%d] = %d\n", i, foo[i]);
        free(foo);
    }

    return 0;
}
```

## 배열 요소의 최댓값 구하기
* 주사(traverse) : 배열의 요소를 하나씩 차레로 살펴보는 과정

```c
// 배열 요소의 최대 값을 구하고 출력(요소 값 입력)
#include <stdio.h>
#include <stdlib.h>

/*--- 요소 개수가 n 인 배열 a의 요소의 최댓값 ---*/
int maxof(const int foo[], int elem_cnt) {
    int max = foo[0];             // 최댓값
    for (int i = 1; i < elem_cnt; i++) {
        if (foo[i] > max) max = foo[i];
    }
    return max;
}

int main(void)
{
    int number;                 // 인원 = 배열 height의 요소 개수
    printf("사람 수: ");
    scanf("%d", &number);
    int *height = calloc(number, sizeof(int));  //요소 개수 number개인 배열을 생성
    printf("%d명의 키를 입력하세요.\n", number);
    for (int i = 0; i < number; i++) {
        printf("height[%d] : ", i);
        scanf("%d", &height[i]);
    }
    printf("최댓값은 %d입니다.\n", maxof(height, number));
    free(height);                               // 배열 height를 해제

    return 0;
}
```


---



# 09-18 5주차 강의

# 양수 음수 구분
```c
    // 입력받은 정숫값의 부호(양수/음수/0)를 판단
    #include<stdio.h>

    int main(void)
    {
        int n;

        printf("정수: ");
        scanf("%d", &n);

        if(n > 0)
            printf("양수입니다.\n");
        else if(n < 0)
            printf("음수입니다.\n");
        else
            printf("0입니다.\n");

        return 0;
    }
```
## 조건 연산자
* 3항 연산자 중에서 ?(물음표)를 **조건 연산자**라 함.
* 일반적으로 물음표의 앞 부분을 **조건절**이라 부름.
```c
    min = x < y ? x: y;
```
* 이 구문은 x가 y보다 작으면 x를, 그렇지 않으면 y를 min에 저장하라는 의미.

# 반복
* 반복 구조(repetition strucrure) 또는 루프(loop):
    * 어떤 조건이 성립하는 동안 처리(프로그램 명령문 또는 명령어의 집합)를 반복해 실행하는 것.
* While(제어식) 명령문
    : 반복의 대상이 되는 '명령문'을 문법적으로는 '루프 본문'이라 함
* 사전 판단 반복
    * 실행 전에 계속 반복할지를 판단.
    * 제어식의 평가 값이 0(false)이 아니면 프로그램 명령문을 반복.

## 1부터 n까지의 총합 구하기
```c
#include<stdio.h>

int main(void)
{
    int n;

    puts("1부터 n까지의 총합을 구합니다.");

    printf("n값: ");
    scanf("%d", &n);

    int sum = 0; // 총합
    int i = 1;
    int sum2 = 0;
    int sum3 = 0;

    while (i <= n)
    {               // i가 n 이하이면 반복
        sum += i;   // sum에 i를 추가
        i++;        // i값을 1증가
    }

    for (int j = 1; j <= n; j++)
    {
        sum2 += j;
    }

    // 가우스의 덧셈 알고리즘
    sum3 = n * (n + 1) / 2;
    printf("가우스의 덧셈 알고리즘으로 구한 1부터 %d까지의 총합은 %d입니다.\n", n, sum3);
    
    printf("while-1부터 %d까지의 총합은 %d입니다.\n", n, sum);
    printf("for-1부터 %d까지의 총합은 %d입니다.\n", n, sum2);

    return 0;
}
```
* while문은 언제 종료 될지 알 수 없는 반복문을 실행할 때 사용.
* for문은 종료 시점이 명확한 반복문을 실행할 때 사용.

## 다중 루프
* 반복 안에서 다시 반복할 수 있음
* 이런 반복을 루프가 중첩되는 수준에 따라 '이중 루프, 삼중 루프' 라고 함.

## 곱셈표
```c
#include <stdio.h>

int main(void)
{
    printf("----- 곱셈표 -----\n");

    for (int i =1; i <=9; i++)
    {
        for (int j = 1; j <= 9; j++)
            printf("%d X %d = %3d", i, j, i * j);
        putchar('\n');
    }

    return 0;
}
```
## 삼각형
```c
#include <stdio.h>

int main(void)
{
    int n;

    printf("몇 단 삼각형입니까?: ");
    scanf("%d", &n);

    //이등변 삼각형
    for (int i =1; i <= n; i++)
    {
        for (int j =1; j <= i; j++)
            putchar('*');
        putchar('\n');
    }

    // 삼각형
    for (int i = 0; i < n; i++)
    {
        for (int j = n-1; j > i; j--)
            putchar(' ');
        for (int j = 0; j < 2*i+1; j++)
            putchar('*');
        putchar('\n');
    }

    return 0;
}
```


---


# 09-11 4주차 강의

[chocolatey 설치 링크](https://chocolatey.org/install "chocolatey")

# 알고리즘
* 매개변수(Parameta) : 함수를 정의할 때 함수에 전달받은 값을 저장하는 변수.
* 인수(Argument) : 함수를 사용할 때 함수의 매개변수로 전달할 값.
* 함수를 호출하는 곳에서 argument를 함수에 전달하면, 함수는 전달받은 인수를 이용해서 함수를 실행한 후 return문으로 결과 값을 호출한 곳으로 보냄.
* return 값의 자료형이 void인 경우 값을 반환하지 않음.

## 알고리즘의 정의
어떤 문제를 해결하기 위한 절차로, 명확하게 정의되고 순서가 있는 유한 개의 규칙으로 이루어진 집합

- 올바른 알고리즘이란
    * '어떠한 경우에도 실행 결과가 똑같이 나오는 것'을 의미.
    * 만약 알고리즘의 실행 결과가 어떤 경우에는 맞고 어떤 경우에는 틀리면 올바른 알고리즘이라고 할 수 없음

# Hello World
* "hello world"를 출력하는 c프로그램.
    ```c
        #include <stdio.h>

        int main () {
            printf("hello world\n");
            return 0;
        }
    ```
* 터미널을 열고 명령 실행
    ```c
        $ gcc -o hello hello.c
    ```
* 명령 실행시 hello.exe 파일이 생성.
* 생성된 실행 파일을 다음과 같이 호출
    ```c
        $ ./hello
        PS> .hello
        >hello
    ```
* 오류가 나는 경우 VSCode 재실행

### 한글깨짐시
* VSCode 오른쪽 밑 UTF-8 클릭 후 인코딩하여 다시 열기 클릭. 본문이 깨졌을 땐 Ctrl + Z를 눌러주면 한글이 다시 돌아오고, 그 상태에서 저장 후 다시 컴파일 후 실행.

## 순서도(flowchart)
- 문제에 대한 정의, 분석, 해법을 그림으로 표현하는 방법.
- 프로그램 순서도(program flowchart)에서 사용되는 기호:
    * 실제로 수행하는 연산을 나타내는 기호
    * 제어의 흐름을 나타내는 기호
    * 프로그램 순서도를 이해하고 작성하는데 편의를 부여하는 특수 기호



---



# 09-04 3주차 강의

[문자 크기](#h1에-해당) / [리스트](#)

# # h1에 해당
## ## h2에 해당
### ### h3에 해당
#### #### h4에 해당
##### ##### h5에 해당
###### ###### h6에 해당

*\*이텔릭체**  
**\*\*볼드체\*\*** <br>
<u>\<u>밑줄\</u></u>

---

# 리스트
* \* 언오디드 리스트
- \- 언오디드 리스트
    * \* 탭
        * \*탭탭
            * \* 변화 없음


1. 오더드 리스트
2. 오더2

# 코드 블럭
```c
    #include <stdio.h>

    int main()
    {
        printf("Hello, world!\n");
        return 0;
    }
```

인라인 코드 블럭 예 : `<br>` 다른 예 : `ctrl`+`A`

# 외부링크
[구글로 가기](http://google.com "구글 링크")

![이미지](/img/images.png "이미지 삽입")